/*
 * Copyright (c) 2025 Skutter.ai
 *
 * This code is proprietary and confidential. Unauthorized copying, modification,
 * distribution, or use of this software, via any medium is strictly prohibited.
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * @author mattduggan
 */

package ai.skutter.common.util;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import org.springframework.stereotype.Service;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.*;
import java.util.stream.Collectors;

@Service
/**
 * Utility class for generating deterministic, short, Base58-encoded IDs from arbitrary input.
 * The IDs are generated by first canonicalizing the input into a stable string representation,
 * then hashing it using SHA-256, and finally Base58-encoding a portion of the hash.
 * This ensures that the same input always produces the same ID, while different inputs
 * are highly likely to produce different IDs.
 */
public class DeterministicIdGenerator {

    private static final Logger log = LoggerFactory.getLogger(DeterministicIdGenerator.class);

    private static final ObjectMapper mapper = createMapper();
    private static final char[] BASE58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz".toCharArray();
    private static final java.math.BigInteger BASE = java.math.BigInteger.valueOf(58);

    // Use ThreadLocal for MessageDigest for thread safety and performance.
    private static final ThreadLocal<MessageDigest> digestCache = ThreadLocal.withInitial(() -> {
        try {
            return MessageDigest.getInstance("SHA-256");
        } catch (NoSuchAlgorithmException e) {
            // SHA-256 is a standard algorithm, should always be available.
            throw new IllegalStateException("SHA-256 not available", e);
        }
    });

    /**
     * Creates and configures the Jackson ObjectMapper used for canonicalization.
     * Ensures stable output by ordering map keys and handling null/empty values consistently.
     *
     * @return A configured ObjectMapper instance.
     */
    private static ObjectMapper createMapper() {
        ObjectMapper om = new ObjectMapper();
        // Sort map keys for consistent JSON output
        om.configure(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS, true);
        // Exclude null map values from the output
        om.configure(SerializationFeature.WRITE_NULL_MAP_VALUES, false);
        // Exclude empty arrays from the output
        om.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false);
        return om;
    }

    /**
     * Generates a standard-length (12 characters) deterministic ID for the given input.
     * This length provides approximately 70 bits of entropy, suitable for millions of unique IDs
     * with a very low probability of collision.
     *
     * @param input The object to generate an ID for. Can be any type, including complex objects, collections, or primitives.
     * @return A 12-character Base58 encoded deterministic ID string.
     */
    public String generateId(Object input) {
        log.debug("Generating standard ID (12 chars) for input type: {}", (input != null ? input.getClass().getSimpleName() : "null"));
        return generateShortId(input, 12); // ~70 bits of entropy, good for 30M+ records
    }

    /**
     * Generates a deterministic ID of a specified length for the given input.
     * The input is canonicalized, hashed (SHA-256), and then a portion of the hash is Base58 encoded
     * to the desired length.
     *
     * @param input        The object to generate an ID for.
     * @param outputLength The desired length of the output Base58 ID string (must be between 8 and 30).
     * @return A Base58 encoded deterministic ID string of the specified length.
     * @throws IllegalArgumentException If the outputLength is less than 8 or greater than 30.
     */
    public String generateShortId(Object input, int outputLength) {
        log.debug("Generating short ID ({} chars) for input type: {}", outputLength, (input != null ? input.getClass().getSimpleName() : "null"));
        if (outputLength < 8 || outputLength > 30) {
            log.warn("Requested output length {} is invalid. Must be between 8 and 30.", outputLength);
            throw new IllegalArgumentException("Output length must be between 8 and 30");
        }

        // 1. Canonicalize the input object into a stable string representation.
        String canonical = canonicalizeInput(input);
        // 2. Hash the canonical string using SHA-256.
        byte[] hash = hashInput(canonical);
        log.trace("Input canonicalized to: '{}', Hash (hex): {}", canonical, bytesToHex(hash));

        // 3. Determine how many bytes of the hash to use based on the desired output length.
        // Base58 encodes roughly log2(58) â‰ˆ 5.857 bits per character.
        // We calculate the minimum number of bytes needed from the hash to achieve the target length entropy.
        int bytesToUse = Math.min(hash.length, (int) Math.ceil(outputLength * Math.log(58) / (Math.log(2) * 8.0)));
        // 4. Base58 encode the selected hash bytes to the target length.
        String generatedId = base58Encode(hash, bytesToUse, outputLength);
        log.debug("Generated short ID: {}", generatedId);
        return generatedId;
    }

    /**
     * Generates a deterministic ID and appends a unique suffix, separated by a hyphen.
     * Useful for creating IDs that are deterministic based on the core input but also include
     * a distinguishing suffix (e.g., a timestamp or counter).
     * Uses a slightly shorter base ID (9 characters) to leave more room for the suffix.
     *
     * @param input        The core object to generate the base ID from.
     * @param uniqueSuffix A non-null, non-empty string suffix to append to the generated ID.
     * @return A combined ID string in the format "{baseId}-{uniqueSuffix}".
     * @throws IllegalArgumentException If the uniqueSuffix is null or empty.
     */
    public String generateUniqueId(Object input, String uniqueSuffix) {
        log.debug("Generating unique ID for input type: {} with suffix: {}", (input != null ? input.getClass().getSimpleName() : "null"), uniqueSuffix);
        if (uniqueSuffix == null || uniqueSuffix.isEmpty()) {
            log.warn("Unique suffix cannot be null or empty.");
            throw new IllegalArgumentException("Unique suffix cannot be null or empty");
        }
        String baseId = generateShortId(input, 9); // Slightly shorter base for the deterministic part
        String uniqueId = baseId + "-" + uniqueSuffix;
        log.debug("Generated unique ID: {}", uniqueId);
        return uniqueId;
    }

    /**
     * Encodes a portion of a byte array (typically a hash) into a Base58 string of a specific length.
     *
     * @param hash       The byte array (hash) to encode.
     * @param bytesToUse The number of bytes from the beginning of the hash to use for encoding.
     * @param length     The target length of the final Base58 string. The result will be padded with
     *                   leading '1's (Base58 zero) or truncated from the left if necessary to match this length.
     * @return The Base58 encoded string of the specified length.
     */
    private String base58Encode(byte[] hash, int bytesToUse, int length) {
        log.trace("Base58 encoding {} bytes of hash to target length {}", bytesToUse, length);
        // Select the relevant portion of the hash
        byte[] selectedBytes = Arrays.copyOfRange(hash, 0, bytesToUse);

        // Count leading zero bytes, as these are significant in Base58 encoding.
        int leadingZeros = 0;
        for (byte b : selectedBytes) {
            if (b == 0) leadingZeros++;
            else break;
        }

        // Convert the selected bytes to a BigInteger
        java.math.BigInteger bi = new java.math.BigInteger(1, selectedBytes);
        StringBuilder result = new StringBuilder(length);

        // Perform standard Base58 encoding (repeated division by 58)
        while (bi.compareTo(java.math.BigInteger.ZERO) > 0) {
            java.math.BigInteger[] divmod = bi.divideAndRemainder(BASE);
            result.append(BASE58[divmod[1].intValue()]);
            bi = divmod[0];
        }

        // Append leading '1's (Base58 zero) for each leading zero byte in the input
        for (int i = 0; i < leadingZeros; i++) {
            result.append(BASE58[0]);
        }

        // Reverse the result (encoding builds the string backwards)
        result.reverse();

        // Pad or truncate the result to match the desired output length
        if (result.length() < length) {
            // Pad with leading '1's if shorter
            result.insert(0, String.valueOf(BASE58[0]).repeat(length - result.length()));
        } else if (result.length() > length) {
            // Truncate from the left if longer
            result.delete(0, result.length() - length);
        }

        return result.toString();
    }

    /**
     * Canonicalizes the input object into a stable string representation.
     * Handles nulls, attempts to parse JSON strings, and then uses the main canonicalize method.
     *
     * @param input The object to canonicalize.
     * @return A stable, canonical string representation of the input. Returns "null" for null input.
     */
    private String canonicalizeInput(Object input) {
        log.trace("Canonicalizing input object of type: {}", (input != null ? input.getClass().getName() : "null"));
        if (input == null) return "null";
        // Attempt to parse the input if it looks like a JSON string
        Object structured = parseIfJson(input);
        // Canonicalize the (potentially parsed) structure
        return canonicalize(structured);
    }

    /**
     * Attempts to parse the input object as JSON if it's a string that looks like a JSON object or array.
     * This allows treating JSON strings equivalently to their parsed object structure for ID generation.
     *
     * @param input The object to potentially parse.
     * @return The parsed JSON object (Map or List) if successful, otherwise the original input object.
     */
    private Object parseIfJson(Object input) {
        if (input instanceof String str) {
            String trimmedStr = str.trim();
            // Basic check if the string starts/ends like a JSON object or array
            if ((trimmedStr.startsWith("{") && trimmedStr.endsWith("}")) || (trimmedStr.startsWith("[") && trimmedStr.endsWith("]"))) {
                try {
                    // Attempt to parse using the configured ObjectMapper
                    Object parsed = mapper.readValue(trimmedStr, Object.class);
                    log.trace("Input string parsed as JSON object.");
                    return parsed;
                } catch (JsonProcessingException e) {
                    // If parsing fails, treat it as a regular string
                    log.trace("Input string looked like JSON but failed to parse: {}", e.getMessage());
                    return input;
                }
            }
        }
        // Return original input if it's not a string or doesn't look like JSON
        return input;
    }

    /**
     * Recursively canonicalizes an object into a stable string representation suitable for hashing.
     * Handles primitives, strings, collections (sorting Sets), and maps (sorting by canonicalized keys).
     * Uses Jackson ObjectMapper for general object serialization as a fallback, ensuring consistent output.
     *
     * @param obj The object to canonicalize.
     * @return A stable string representation of the object.
     */
    private String canonicalize(Object obj) {
        log.trace("Canonicalize: Processing object of type: {}", (obj != null ? obj.getClass().getName() : "null"));
        if (obj == null) {
            return "null";
        }
        // Handle strings: escape quotes and wrap in quotes
        if (obj instanceof String str) {
            return "\"" + str.replace("\"", "\\\"") + "\"";
        }
        // Handle numbers and booleans directly
        if (obj instanceof Number || obj instanceof Boolean) {
            return obj.toString();
        }
        // Explicitly handle Collections and Maps first using our custom canonicalization
        if (obj instanceof Collection<?>) {
            return canonicalizeCollection((Collection<?>) obj);
        }
        if (obj instanceof Map<?, ?>) {
            return canonicalizeMap((Map<?, ?>) obj);
        }

        // For other types (like POJOs), attempt to serialize using Jackson
        try {
            // Attempt to serialize using the pre-configured ObjectMapper for complex types
            // This handles POJOs consistently (e.g., sorted map keys by Jackson config)
            String jsonResult = mapper.writeValueAsString(obj);
            log.trace("Canonicalized via Jackson to: {}", jsonResult);
            return jsonResult;
        } catch (JsonProcessingException e) {
            // Final fallback: use toString()
            // This might happen for types Jackson cannot serialize and are not Collections/Maps
            log.warn("Jackson serialization failed for type {}. Falling back to toString(). Exception: {}", obj.getClass().getName(), e.getMessage());
            return obj.toString();
        }
    }

    /**
     * Canonicalizes a collection into a stable string representation.
     * For Sets, elements are canonicalized, sorted alphabetically, and joined.
     * For Lists (or other ordered collections), elements are canonicalized and joined in their original order.
     *
     * @param collection The collection to canonicalize.
     * @return A string representation like "[elem1,elem2,...]". For Sets, elements are sorted.
     */
    private String canonicalizeCollection(Collection<?> collection) {
        log.trace("Canonicalizing collection of type: {}", collection.getClass().getName());
        if (collection instanceof Set<?>) {
            // Sort elements for Sets to ensure order doesn't affect the ID
            log.trace("Collection is a Set, sorting elements before joining.");
            return collection.stream()
                .map(this::canonicalize) // Canonicalize each element
                .sorted()                // Sort the canonicalized strings
                .collect(Collectors.joining(",", "[", "]"));
        } else {
            // For lists or other ordered collections, maintain order
            log.trace("Collection is not a Set, preserving element order.");
            return collection.stream()
                .map(this::canonicalize) // Canonicalize each element
                .collect(Collectors.joining(",", "[", "]"));
        }
    }

    /**
     * Canonicalizes a map into a stable string representation.
     * Entries are sorted based on the canonicalized string representation of their keys
     * before being joined into the final string.
     *
     * @param map The map to canonicalize.
     * @return A string representation like "{key1:value1,key2:value2,...}" with keys sorted alphabetically based on their canonical form.
     */
    private String canonicalizeMap(Map<?, ?> map) {
        log.trace("Canonicalizing map of type: {}", map.getClass().getName());
        return map.entrySet().stream()
            // Sort entries by the canonical representation of the key
            .sorted(Map.Entry.comparingByKey(Comparator.comparing(this::canonicalize)))
            // Format each entry as "canonicalKey:canonicalValue"
            .map(e -> canonicalize(e.getKey()) + ":" + canonicalize(e.getValue()))
            .collect(Collectors.joining(",", "{", "}"));
    }

    /**
     * Hashes the canonical input string using SHA-256.
     * Uses a ThreadLocal MessageDigest instance for efficiency and thread safety.
     *
     * @param input The canonical string representation of the original input object.
     * @return The SHA-256 hash of the input string as a byte array.
     */
    private byte[] hashInput(String input) {
        log.trace("Hashing canonical input string (length: {} chars)", input.length());
        MessageDigest digest = digestCache.get();
        digest.reset(); // Reset digest for reuse
        byte[] hash = digest.digest(input.getBytes(StandardCharsets.UTF_8));
        log.trace("SHA-256 Hash generated ({} bytes)", hash.length);
        return hash;
    }

    // Helper method to convert byte array to hex string for logging
    private static String bytesToHex(byte[] bytes) {
        StringBuilder hexString = new StringBuilder(2 * bytes.length);
        for (byte b : bytes) {
            String hex = Integer.toHexString(0xff & b);
            if (hex.length() == 1) {
                hexString.append('0');
            }
            hexString.append(hex);
        }
        return hexString.toString();
    }
}
