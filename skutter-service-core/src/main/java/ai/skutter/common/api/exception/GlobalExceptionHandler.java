/*
 * Copyright (c) 2025 Skutter.ai
 *
 * This code is proprietary and confidential. Unauthorized copying, modification,
 * distribution, or use of this software, via any medium is strictly prohibited.
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * @author mattduggan
 */
package ai.skutter.common.api.exception;

import ai.skutter.common.api.model.ApiErrorResponse;
import ai.skutter.common.observability.filter.CorrelationIdFilter;
import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpStatusCode;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.core.AuthenticationException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;
import org.slf4j.MDC;

import java.time.LocalDateTime;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Global exception handler for standardized API error responses.
 */
@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {

    // Base URL for error documentation links (replace with actual URL when available)
    private static final String ERROR_DOCS_BASE_URL = "https://api.skutter.ai/docs/errors"; 

    /**
     * Handles generic RuntimeExceptions and other unhandled exceptions.
     */
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiErrorResponse> handleGenericException(
            Exception ex, HttpServletRequest request) {
        
        HttpStatus status = HttpStatus.INTERNAL_SERVER_ERROR;
        String errorCode = "internal_server_error";
        String message = "An unexpected internal error occurred.";
        log.error("Unexpected error occurred. Correlation ID: {}", getCorrelationId(), ex);

        ApiErrorResponse errorResponse = buildApiErrorResponse(status, errorCode, message, ex.getMessage(), request);
        HttpHeaders headers = createCommonHeaders(request);
        addLinkHeader(headers, status);
        
        return new ResponseEntity<>(errorResponse, headers, status);
    }
    
    /**
     * Handles specific application-level exceptions.
     */
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ApiErrorResponse> handleResourceNotFoundException(
            ResourceNotFoundException ex, HttpServletRequest request) {
            
        HttpStatus status = HttpStatus.NOT_FOUND;
        String errorCode = "resource_not_found";
        log.warn("Resource not found: {}. Correlation ID: {}", ex.getMessage(), getCorrelationId(request));

        ApiErrorResponse errorResponse = buildApiErrorResponse(status, errorCode, "Resource Not Found", ex.getMessage(), request);
        HttpHeaders headers = createCommonHeaders(request);
        addLinkHeader(headers, status);
        
        return new ResponseEntity<>(errorResponse, headers, status);
    }

    /**
     * Handles Spring Security Authentication exceptions (e.g., bad JWT signature, expired token).
     * Note: The primary 401 response might be generated by CustomBearerAuthenticationEntryPoint.
     * This handler catches exceptions further down the filter chain if needed.
     */
    @ExceptionHandler(AuthenticationException.class)
    public ResponseEntity<ApiErrorResponse> handleAuthenticationException(
            AuthenticationException ex, HttpServletRequest request) {
            
        HttpStatus status = HttpStatus.UNAUTHORIZED;
        String errorCode = "authentication_failed";
        log.warn("Authentication failed: {}. Correlation ID: {}", ex.getMessage(), getCorrelationId(request));

        ApiErrorResponse errorResponse = buildApiErrorResponse(status, errorCode, "Authentication Failed", ex.getMessage(), request);
        HttpHeaders headers = createCommonHeaders(request);
        addWwwAuthenticateHeader(headers);
        addLinkHeader(headers, status);
        
        return new ResponseEntity<>(errorResponse, headers, status);
    }
    
    /**
     * Handles Spring Security Access Denied exceptions (insufficient permissions/roles).
     * Note: The primary 403 response might be generated by CustomBearerAccessDeniedHandler.
     */
    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ApiErrorResponse> handleAccessDeniedException(
            AccessDeniedException ex, HttpServletRequest request) {
            
        HttpStatus status = HttpStatus.FORBIDDEN;
        String errorCode = "insufficient_permissions";
        log.warn("Access denied: {}. Correlation ID: {}", ex.getMessage(), getCorrelationId(request));

        ApiErrorResponse errorResponse = buildApiErrorResponse(status, errorCode, "Permission Denied", ex.getMessage(), request);
        HttpHeaders headers = createCommonHeaders(request);
        addLinkHeader(headers, status);

        return new ResponseEntity<>(errorResponse, headers, status);
    }

    /**
     * Handles Rate Limit exceptions.
     */
    @ExceptionHandler(RateLimitExceededException.class)
    public ResponseEntity<ApiErrorResponse> handleRateLimitExceededException(
            RateLimitExceededException ex, HttpServletRequest request) {
            
        log.warn("Rate limit exceeded: {}. Correlation ID: {}", ex.getMessage(), getCorrelationId());

        HttpStatus status = HttpStatus.TOO_MANY_REQUESTS;
        String errorCode = "rate_limit_exceeded";

        ApiErrorResponse errorResponse = buildApiErrorResponse(status, errorCode, "Rate Limit Exceeded", ex.getMessage(), request);
        HttpHeaders headers = createCommonHeaders(request);
        headers.add(HttpHeaders.RETRY_AFTER, "60");
        addLinkHeader(headers, status);
        
        return new ResponseEntity<>(errorResponse, headers, status);
    }

    /**
     * Handles validation errors from @Valid annotation.
     */
    @Override
    protected ResponseEntity<Object> handleMethodArgumentNotValid(
            MethodArgumentNotValidException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {

        HttpStatus httpStatus = HttpStatus.BAD_REQUEST;
        String errorCode = "validation_error";
        String message = "Validation failed for request data.";
        log.warn("Validation failed: {}. Correlation ID: {}", ex.getMessage(), getCorrelationId(request));

        // Extract field validation errors
        Map<String, String> validationErrors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> 
            validationErrors.put(error.getField(), error.getDefaultMessage()));
        ex.getBindingResult().getGlobalErrors().forEach(error -> 
             validationErrors.put(error.getObjectName(), error.getDefaultMessage()));
             
        String details = validationErrors.entrySet().stream()
                             .map(entry -> entry.getKey() + ": " + entry.getValue())
                             .collect(Collectors.joining("; "));

        ApiErrorResponse errorResponse = buildApiErrorResponse(httpStatus, errorCode, message, details, request);
        HttpHeaders responseHeaders = createCommonHeaders(request);
        addLinkHeader(responseHeaders, httpStatus);

        return new ResponseEntity<>(errorResponse, responseHeaders, httpStatus);
    }

    /**
     * Handles errors when the request body is missing or malformed JSON.
     */
    @Override
    protected ResponseEntity<Object> handleHttpMessageNotReadable(
            HttpMessageNotReadableException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {
            
        HttpStatus httpStatus = HttpStatus.BAD_REQUEST;
        String errorCode = "invalid_request_body";
        String message = "Failed to read request body. Ensure it is valid JSON.";
        log.warn("HTTP message not readable: {}. Correlation ID: {}", ex.getMessage(), getCorrelationId(request));

        ApiErrorResponse errorResponse = buildApiErrorResponse(httpStatus, errorCode, message, ex.getLocalizedMessage(), request);
        HttpHeaders responseHeaders = createCommonHeaders(request);
        addLinkHeader(responseHeaders, httpStatus);

        return new ResponseEntity<>(errorResponse, responseHeaders, httpStatus);
    }
    
    // --- Helper Methods ---

    /**
     * Builds the standardized ApiErrorResponse object.
     */
    private ApiErrorResponse buildApiErrorResponse(HttpStatus status, String errorCode, String message, String details, HttpServletRequest request) {
         return buildApiErrorResponse(status.value(), errorCode, message, details, getCorrelationId(request), request.getRequestURI());
    }
    
     private ApiErrorResponse buildApiErrorResponse(HttpStatusCode status, String errorCode, String message, String details, WebRequest request) {
         String path = request.getDescription(false);
         if(path.startsWith("uri=")) {
             path = path.substring(4);
         }
        return buildApiErrorResponse(status.value(), errorCode, message, details, getCorrelationId(request), path);
    }
    
    private ApiErrorResponse buildApiErrorResponse(int statusCode, String errorCode, String message, String details, String correlationId, String path) {
         ApiErrorResponse.ErrorDetails errorDetails = ApiErrorResponse.ErrorDetails.builder()
            .code(errorCode)
            .message(message)
            .details(details)
            .requestId(correlationId)
            .path(path)
            .build();
            
        return ApiErrorResponse.builder()
                .error(errorDetails)
                .build();
    }

    /**
     * Creates common headers including X-Correlation-ID.
     */
    private HttpHeaders createCommonHeaders(WebRequest request) {
        HttpHeaders headers = new HttpHeaders();
        headers.add(HttpHeaders.CONTENT_TYPE, "application/json"); // Ensure correct content type
        String correlationId = getCorrelationId(request);
        if (correlationId != null) {
            headers.add(CorrelationIdFilter.CORRELATION_ID_KEY, correlationId);
        }
        return headers;
    }

    private HttpHeaders createCommonHeaders(HttpServletRequest request) {
        HttpHeaders headers = new HttpHeaders();
        headers.add(HttpHeaders.CONTENT_TYPE, "application/json"); 
        String correlationId = getCorrelationId(request);
        if (correlationId != null) {
            headers.add(CorrelationIdFilter.CORRELATION_ID_KEY, correlationId);
        }
        return headers;
    }

    /**
     * Adds the WWW-Authenticate header for 401 responses.
     */
    private void addWwwAuthenticateHeader(HttpHeaders headers) {
        headers.add(HttpHeaders.WWW_AUTHENTICATE, "Bearer realm=\"api\"");
    }

    /**
     * Adds a Link header pointing to error documentation.
     */
    private void addLinkHeader(HttpHeaders headers, HttpStatusCode status) {
         addLinkHeader(headers, status.value());
    }
    
     private void addLinkHeader(HttpHeaders headers, HttpStatus status) {
         addLinkHeader(headers, status.value());
    }
    
     private void addLinkHeader(HttpHeaders headers, int statusCode) {
        // Construct URL based on status code - replace with your actual doc structure
        String url = String.format("%s/%d", ERROR_DOCS_BASE_URL, statusCode);
        headers.add(HttpHeaders.LINK, String.format("<%s>; rel=\"help\"", url));
    }
    
     /**
     * Safely retrieves the correlation ID from the request.
     */
     private String getCorrelationId() {
        // Try MDC first
        String correlationId = MDC.get(CorrelationIdFilter.CORRELATION_ID_KEY);
        if (correlationId != null) {
            return correlationId;
        }
        // Fallback or log warning if necessary, but shouldn't be null if filter ran
        log.warn("Correlation ID not found in MDC.");
        return null;
    }
    
    private String getCorrelationId(HttpServletRequest request) {
        String correlationId = getCorrelationId(); // Try MDC first
        if (correlationId != null) {
            return correlationId;
        }
        // Fallback to header if MDC fails (less reliable)
        return request != null ? request.getHeader(CorrelationIdFilter.CORRELATION_ID_KEY) : null;
    }
    
    private String getCorrelationId(WebRequest request) {
         String correlationId = getCorrelationId(); // Try MDC first
        if (correlationId != null) {
            return correlationId;
        }
        // Fallback to header if MDC fails (less reliable)
        return request != null ? request.getHeader(CorrelationIdFilter.CORRELATION_ID_KEY) : null;
    }
} 